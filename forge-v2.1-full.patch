diff --git a/.env.example b/.env.example
index 60ade67..e57fe34 100644
--- a/.env.example
+++ b/.env.example
@@ -1,3 +1,21 @@
-# Get your API key from https://console.anthropic.com/settings/keys
-ANTHROPIC_API_KEY=sk-ant-xxxxxxxxxxxxx
+# â”€â”€â”€ FORGE Configuration â”€â”€â”€
+
 PORT=3000
+
+# â”€â”€â”€ AI Provider â”€â”€â”€
+# Configure here OR in the app's Settings UI (Settings > AI Coach Provider).
+# UI config overrides .env.
+
+# Option 1: Anthropic (simplest â€” just set the key)
+ANTHROPIC_API_KEY=sk-ant-xxxxxxxxxxxxx
+
+# Option 2: Explicit provider (overrides ANTHROPIC_API_KEY)
+# AI_PROVIDER=anthropic          # anthropic | openai | gemini | openai-compatible
+# AI_MODEL=claude-sonnet-4-20250514
+# AI_API_KEY=your-key-here
+
+# Option 3: Local LLM (Ollama, LM Studio, vLLM)
+# AI_PROVIDER=openai-compatible
+# AI_MODEL=llama3.1:8b
+# AI_BASE_URL=http://localhost:11434/v1
+# AI_SUPPORTS_TOOLS=true
diff --git a/ai-provider.js b/ai-provider.js
new file mode 100644
index 0000000..d5e2a9b
--- /dev/null
+++ b/ai-provider.js
@@ -0,0 +1,333 @@
+// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+// FORGE AI Provider Abstraction
+// Supports: Anthropic, OpenAI, Gemini, OpenAI-compatible (Ollama, LM Studio, etc.)
+// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+import Anthropic from "@anthropic-ai/sdk";
+
+// â”€â”€â”€ Base Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+class AIProvider {
+  constructor(config) {
+    this.config = config;
+  }
+
+  get providerName() { return "base"; }
+  get modelName() { return this.config.model; }
+
+  async chat(system, messages, options = {}) {
+    throw new Error("chat() not implemented");
+  }
+
+  async chatWithTools(system, messages, tools, options = {}) {
+    // Default: JSON-prompt fallback for providers without native tool use
+    return this._jsonFallback(system, messages, tools, options);
+  }
+
+  async _jsonFallback(system, messages, tools, options) {
+    const toolDesc = tools.map(t =>
+      `Tool: ${t.name}\nDescription: ${t.description}\nParameters: ${JSON.stringify(t.input_schema, null, 2)}`
+    ).join("\n\n");
+
+    const augmented = `${system}
+
+When you need to use a tool, respond with ONLY a JSON code block in this exact format (no other text):
+\`\`\`json
+{"tool": "tool_name", "input": {<parameters matching the schema>}}
+\`\`\`
+
+Available tools:
+${toolDesc}`;
+
+    const result = await this.chat(augmented, messages, options);
+
+    // Try to extract tool call from response
+    try {
+      // Match ```json ... ``` or bare JSON
+      const codeBlock = result.text.match(/```(?:json)?\s*([\s\S]*?)```/);
+      const raw = codeBlock ? codeBlock[1].trim() : result.text.trim();
+      const jsonMatch = raw.match(/\{[\s\S]*\}/);
+      if (jsonMatch) {
+        const parsed = JSON.parse(jsonMatch[0]);
+        if (parsed.tool && parsed.input) {
+          return { text: null, toolCalls: [{ name: parsed.tool, input: parsed.input }] };
+        }
+      }
+    } catch (e) { /* not valid JSON, treat as text */ }
+
+    return { text: result.text, toolCalls: [] };
+  }
+}
+
+// â”€â”€â”€ Anthropic Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+class AnthropicProvider extends AIProvider {
+  constructor(config) {
+    super(config);
+    this.client = new Anthropic({ apiKey: config.apiKey });
+  }
+
+  get providerName() { return "anthropic"; }
+
+  async chat(system, messages, options = {}) {
+    const msg = await this.client.messages.create({
+      model: this.config.model || "claude-sonnet-4-20250514",
+      max_tokens: options.maxTokens || 1500,
+      system,
+      messages,
+    });
+    return { text: msg.content.map(b => b.type === "text" ? b.text : "").join("\n") };
+  }
+
+  async chatWithTools(system, messages, tools, options = {}) {
+    const msg = await this.client.messages.create({
+      model: this.config.model || "claude-sonnet-4-20250514",
+      max_tokens: options.maxTokens || 4000,
+      system,
+      messages,
+      tools: tools.map(t => ({
+        name: t.name,
+        description: t.description,
+        input_schema: t.input_schema,
+      })),
+    });
+
+    const text = msg.content.filter(b => b.type === "text").map(b => b.text).join("\n") || null;
+    const toolCalls = msg.content.filter(b => b.type === "tool_use").map(b => ({
+      name: b.name,
+      input: b.input,
+    }));
+
+    return { text, toolCalls };
+  }
+}
+
+// â”€â”€â”€ OpenAI-Compatible Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Works with: OpenAI, Ollama, LM Studio, vLLM, Together, Groq, Fireworks, etc.
+
+class OpenAICompatibleProvider extends AIProvider {
+  constructor(config) {
+    super(config);
+    this.baseUrl = (config.baseUrl || "https://api.openai.com/v1").replace(/\/$/, "");
+    this.apiKey = config.apiKey;
+    this.supportsTools = config.supportsTools !== false; // assume yes unless explicitly disabled
+  }
+
+  get providerName() { return "openai-compatible"; }
+
+  async _call(body) {
+    const headers = { "Content-Type": "application/json" };
+    if (this.apiKey) headers["Authorization"] = `Bearer ${this.apiKey}`;
+
+    const res = await fetch(`${this.baseUrl}/chat/completions`, {
+      method: "POST",
+      headers,
+      body: JSON.stringify(body),
+    });
+
+    if (!res.ok) {
+      const err = await res.text().catch(() => "Unknown error");
+      throw new Error(`OpenAI-compatible API error (${res.status}): ${err}`);
+    }
+
+    return res.json();
+  }
+
+  async chat(system, messages, options = {}) {
+    const data = await this._call({
+      model: this.config.model || "gpt-4o",
+      max_tokens: options.maxTokens || 1500,
+      messages: [{ role: "system", content: system }, ...messages],
+    });
+    return { text: data.choices?.[0]?.message?.content || "" };
+  }
+
+  async chatWithTools(system, messages, tools, options = {}) {
+    if (!this.supportsTools) {
+      return this._jsonFallback(system, messages, tools, options);
+    }
+
+    try {
+      const data = await this._call({
+        model: this.config.model || "gpt-4o",
+        max_tokens: options.maxTokens || 4000,
+        messages: [{ role: "system", content: system }, ...messages],
+        tools: tools.map(t => ({
+          type: "function",
+          function: {
+            name: t.name,
+            description: t.description,
+            parameters: t.input_schema,
+          },
+        })),
+      });
+
+      const msg = data.choices?.[0]?.message;
+      const text = msg?.content || null;
+      const toolCalls = (msg?.tool_calls || []).map(tc => ({
+        name: tc.function.name,
+        input: JSON.parse(tc.function.arguments),
+      }));
+
+      return { text, toolCalls };
+    } catch (e) {
+      // If tool use fails (unsupported model), fall back to JSON prompt
+      console.warn("Tool use failed, falling back to JSON prompt:", e.message);
+      this.supportsTools = false;
+      return this._jsonFallback(system, messages, tools, options);
+    }
+  }
+}
+
+// â”€â”€â”€ Gemini Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+class GeminiProvider extends AIProvider {
+  constructor(config) {
+    super(config);
+    this.apiKey = config.apiKey;
+  }
+
+  get providerName() { return "gemini"; }
+
+  async _call(body, toolDeclarations = null) {
+    const model = this.config.model || "gemini-2.0-flash";
+    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`;
+
+    const payload = { ...body };
+    if (toolDeclarations) {
+      payload.tools = [{ functionDeclarations: toolDeclarations }];
+    }
+
+    const res = await fetch(url, {
+      method: "POST",
+      headers: { "Content-Type": "application/json" },
+      body: JSON.stringify(payload),
+    });
+
+    if (!res.ok) {
+      const err = await res.text().catch(() => "Unknown error");
+      throw new Error(`Gemini API error (${res.status}): ${err}`);
+    }
+
+    return res.json();
+  }
+
+  _buildBody(system, messages, options = {}) {
+    return {
+      systemInstruction: { parts: [{ text: system }] },
+      contents: messages.map(m => ({
+        role: m.role === "assistant" ? "model" : "user",
+        parts: [{ text: m.content }],
+      })),
+      generationConfig: { maxOutputTokens: options.maxTokens || 1500 },
+    };
+  }
+
+  async chat(system, messages, options = {}) {
+    const data = await this._call(this._buildBody(system, messages, options));
+    const text = data.candidates?.[0]?.content?.parts?.map(p => p.text || "").join("") || "";
+    return { text };
+  }
+
+  async chatWithTools(system, messages, tools, options = {}) {
+    const toolDeclarations = tools.map(t => ({
+      name: t.name,
+      description: t.description,
+      parameters: t.input_schema,
+    }));
+
+    const data = await this._call(
+      this._buildBody(system, messages, options),
+      toolDeclarations
+    );
+
+    const parts = data.candidates?.[0]?.content?.parts || [];
+    const text = parts.filter(p => p.text).map(p => p.text).join("") || null;
+    const toolCalls = parts.filter(p => p.functionCall).map(p => ({
+      name: p.functionCall.name,
+      input: p.functionCall.args,
+    }));
+
+    return { text, toolCalls };
+  }
+}
+
+// â”€â”€â”€ Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+export function createProvider(config) {
+  if (!config || (!config.apiKey && config.provider !== "openai-compatible")) {
+    return null;
+  }
+
+  switch (config.provider) {
+    case "anthropic":
+      return new AnthropicProvider(config);
+    case "openai":
+      return new OpenAICompatibleProvider({ ...config, baseUrl: "https://api.openai.com/v1" });
+    case "gemini":
+      return new GeminiProvider(config);
+    case "openai-compatible":
+      if (!config.baseUrl) throw new Error("baseUrl required for openai-compatible provider");
+      return new OpenAICompatibleProvider(config);
+    default:
+      throw new Error(`Unknown AI provider: ${config.provider}`);
+  }
+}
+
+// â”€â”€â”€ Config Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+// Resolves AI config from: DB settings â†’ .env â†’ legacy ANTHROPIC_API_KEY
+
+export function resolveConfig(dbSettings, env) {
+  // DB settings take priority
+  if (dbSettings?.provider) {
+    return {
+      provider: dbSettings.provider,
+      model: dbSettings.model || defaultModelFor(dbSettings.provider),
+      apiKey: dbSettings.apiKey || "",
+      baseUrl: dbSettings.baseUrl || "",
+      supportsTools: dbSettings.supportsTools !== "false",
+    };
+  }
+
+  // .env AI_PROVIDER config
+  if (env.AI_PROVIDER) {
+    return {
+      provider: env.AI_PROVIDER,
+      model: env.AI_MODEL || defaultModelFor(env.AI_PROVIDER),
+      apiKey: env.AI_API_KEY || "",
+      baseUrl: env.AI_BASE_URL || "",
+      supportsTools: env.AI_SUPPORTS_TOOLS !== "false",
+    };
+  }
+
+  // Legacy fallback: ANTHROPIC_API_KEY
+  if (env.ANTHROPIC_API_KEY) {
+    return {
+      provider: "anthropic",
+      model: env.AI_MODEL || "claude-sonnet-4-20250514",
+      apiKey: env.ANTHROPIC_API_KEY,
+      baseUrl: "",
+    };
+  }
+
+  return null;
+}
+
+export function defaultModelFor(provider) {
+  switch (provider) {
+    case "anthropic": return "claude-sonnet-4-20250514";
+    case "openai": return "gpt-4o";
+    case "gemini": return "gemini-2.0-flash";
+    case "openai-compatible": return "default";
+    default: return "";
+  }
+}
+
+// â”€â”€â”€ Provider Info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+export const PROVIDERS = [
+  { id: "anthropic", name: "Anthropic (Claude)", models: ["claude-sonnet-4-20250514", "claude-haiku-4-5-20251001"] },
+  { id: "openai", name: "OpenAI", models: ["gpt-4o", "gpt-4o-mini", "gpt-4.1", "gpt-4.1-mini", "o4-mini"] },
+  { id: "gemini", name: "Google Gemini", models: ["gemini-2.0-flash", "gemini-2.5-pro", "gemini-2.5-flash"] },
+  { id: "openai-compatible", name: "OpenAI-Compatible (Ollama, LM Studio, etc.)", models: [] },
+];
diff --git a/package.json b/package.json
index 81d9bf6..f8e9c68 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "forge",
-  "version": "2.0.0",
-  "description": "Multi-user gym tracking app with AI coaching",
+  "version": "2.1.0",
+  "description": "Multi-user gym tracking app with AI coaching and multi-provider support",
   "type": "module",
   "scripts": {
     "dev": "concurrently \"node server.js\" \"vite\"",
diff --git a/server.js b/server.js
index 40f31f3..1e9cafe 100644
--- a/server.js
+++ b/server.js
@@ -4,8 +4,9 @@ import crypto from "crypto";
 import { fileURLToPath } from "url";
 import { dirname, join } from "path";
 import Database from "better-sqlite3";
-import Anthropic from "@anthropic-ai/sdk";
 import dotenv from "dotenv";
+import { createProvider, resolveConfig, defaultModelFor, PROVIDERS } from "./ai-provider.js";
+import { EXERCISES } from "./src/exercises.js";
 
 dotenv.config();
 
@@ -83,6 +84,11 @@ db.exec(`
     created_by TEXT,
     created_at TEXT DEFAULT (datetime('now'))
   );
+
+  CREATE TABLE IF NOT EXISTS ai_config (
+    key TEXT PRIMARY KEY,
+    value TEXT
+  );
 `);
 
 // --- Migrate profiles table (safe â€” ignores if columns already exist) ---
@@ -110,15 +116,41 @@ function genId() {
   return Date.now().toString(36) + Math.random().toString(36).substr(2, 6);
 }
 
-// --- Anthropic ---
-let anthropic = null;
-if (process.env.ANTHROPIC_API_KEY) {
-  anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
-  console.log("âœ… Anthropic API key loaded");
-} else {
-  console.warn("âš ï¸  No ANTHROPIC_API_KEY â€” AI coach unavailable");
+// --- AI Provider ---
+function loadAIConfig() {
+  const rows = db.prepare("SELECT key, value FROM ai_config").all();
+  const dbSettings = {};
+  rows.forEach(r => { dbSettings[r.key] = r.value; });
+  return dbSettings;
 }
 
+function initProvider() {
+  const dbSettings = loadAIConfig();
+  const config = resolveConfig(dbSettings, process.env);
+  if (!config) {
+    console.warn("âš ï¸  No AI provider configured â€” AI coach unavailable");
+    return null;
+  }
+  try {
+    const p = createProvider(config);
+    console.log(`âœ… AI: ${config.provider} (${config.model})`);
+    return p;
+  } catch (e) {
+    console.error("âŒ AI provider init failed:", e.message);
+    return null;
+  }
+}
+
+let aiProvider = initProvider();
+
+// Exercise list for AI context
+const exerciseNames = EXERCISES.map(e => e.name).sort();
+const exercisesByMuscle = {};
+EXERCISES.forEach(e => {
+  if (!exercisesByMuscle[e.muscle]) exercisesByMuscle[e.muscle] = [];
+  exercisesByMuscle[e.muscle].push(`${e.name} (${e.equipment}, ${e.type})`);
+});
+
 // --- Middleware ---
 app.use(cors());
 app.use(express.json({ limit: "5mb" }));
@@ -311,25 +343,187 @@ app.delete("/api/exercises/:id", (req, res) => {
   res.json({ ok: true });
 });
 
+// ===================== AI CONFIG =====================
+
+app.get("/api/ai/config", (req, res) => {
+  const dbSettings = loadAIConfig();
+  const config = resolveConfig(dbSettings, process.env);
+  res.json({
+    provider: config?.provider || "",
+    model: config?.model || "",
+    baseUrl: dbSettings.baseUrl || process.env.AI_BASE_URL || "",
+    hasKey: !!(config?.apiKey),
+    supportsTools: dbSettings.supportsTools !== "false",
+    enabled: !!aiProvider,
+    providerName: aiProvider?.providerName || "",
+    providers: PROVIDERS,
+  });
+});
+
+app.put("/api/ai/config", (req, res) => {
+  const { provider, model, apiKey, baseUrl, supportsTools } = req.body;
+  const upsert = db.prepare("INSERT INTO ai_config (key, value) VALUES (?, ?) ON CONFLICT(key) DO UPDATE SET value = excluded.value");
+  if (provider !== undefined) upsert.run("provider", provider);
+  if (model !== undefined) upsert.run("model", model);
+  if (apiKey !== undefined) upsert.run("apiKey", apiKey);
+  if (baseUrl !== undefined) upsert.run("baseUrl", baseUrl);
+  if (supportsTools !== undefined) upsert.run("supportsTools", String(supportsTools));
+
+  // Reinitialize provider
+  aiProvider = initProvider();
+  res.json({ ok: true, enabled: !!aiProvider, providerName: aiProvider?.providerName || "" });
+});
+
 // ===================== AI COACH =====================
 
+const COACH_SYSTEM = `You are a knowledgeable strength training coach analyzing real workout data. The user's profile includes biometric data, training goals, experience level, injury notes, and nutrition targets â€” use all available context to personalize your advice. Give specific, evidence-based advice with exact numbers (weights, reps, sets). Be concise and actionable. Consider any injuries mentioned. Format with clear sections but keep it tight. No fluff.`;
+
 app.post("/api/coach", async (req, res) => {
-  if (!anthropic) return res.status(503).json({ error: "AI coach unavailable â€” no API key configured" });
+  if (!aiProvider) return res.status(503).json({ error: "AI coach unavailable â€” no provider configured" });
   const { prompt, context } = req.body;
   try {
-    const msg = await anthropic.messages.create({
-      model: "claude-sonnet-4-20250514",
-      max_tokens: 1500,
-      system: `You are a knowledgeable strength training coach analyzing real workout data. The user's profile includes biometric data, training goals, experience level, injury notes, and nutrition targets â€” use all available context to personalize your advice. Give specific, evidence-based advice with exact numbers (weights, reps, sets). Be concise and actionable. Consider any injuries mentioned. Format with clear sections but keep it tight. No fluff.`,
-      messages: [{ role: "user", content: `${context}\n\nQUESTION: ${prompt}` }],
-    });
-    res.json({ response: msg.content.map(b => b.type === "text" ? b.text : "").join("\n") });
+    const result = await aiProvider.chat(COACH_SYSTEM, [
+      { role: "user", content: `${context}\n\nQUESTION: ${prompt}` },
+    ], { maxTokens: 1500 });
+    res.json({ response: result.text });
   } catch (e) {
     console.error("Coach error:", e.message);
     res.status(500).json({ error: e.message });
   }
 });
 
+// ===================== AI PROGRAM BUILDER =====================
+
+const PROGRAM_TOOL = {
+  name: "create_program",
+  description: "Create a structured workout program with named days and exercises. Use ONLY exercises from the provided library. Each exercise needs sets and rep targets.",
+  input_schema: {
+    type: "object",
+    properties: {
+      name: { type: "string", description: "Program name (e.g. 'Push/Pull/Legs', '4-Day Upper/Lower')" },
+      description: { type: "string", description: "Brief program description" },
+      days: {
+        type: "array",
+        description: "The training days in the program",
+        items: {
+          type: "object",
+          properties: {
+            label: { type: "string", description: "Day name (e.g. 'Push 1', 'Upper A', 'Leg Day')" },
+            subtitle: { type: "string", description: "Optional focus note (e.g. 'Chest/Triceps Focus', 'Heavy Compounds')" },
+            exercises: {
+              type: "array",
+              items: {
+                type: "object",
+                properties: {
+                  name: { type: "string", description: "Exercise name â€” MUST match an exercise from the provided library exactly" },
+                  defaultSets: { type: "integer", description: "Number of working sets (typically 3-5)" },
+                  targetReps: { type: "string", description: "Rep target or range (e.g. '5', '8-12', '12-15')" },
+                  notes: { type: "string", description: "Optional coaching notes for this exercise" },
+                },
+                required: ["name", "defaultSets", "targetReps"],
+              },
+            },
+          },
+          required: ["label", "exercises"],
+        },
+      },
+    },
+    required: ["name", "days"],
+  },
+};
+
+app.post("/api/coach/program", async (req, res) => {
+  if (!aiProvider) return res.status(503).json({ error: "AI coach unavailable â€” no provider configured" });
+  const { prompt, context } = req.body;
+
+  // Build exercise library context
+  const exerciseLib = Object.entries(exercisesByMuscle).map(([muscle, exs]) =>
+    `${muscle.toUpperCase()}: ${exs.join(", ")}`
+  ).join("\n");
+
+  // Add custom exercises
+  const customExs = db.prepare("SELECT name, muscle, equipment, type FROM custom_exercises").all();
+  const customLib = customExs.length > 0
+    ? `\nCUSTOM EXERCISES: ${customExs.map(e => `${e.name} (${e.muscle}, ${e.equipment}, ${e.type})`).join(", ")}`
+    : "";
+
+  const system = `You are an expert strength training coach creating a workout program. You MUST use the create_program tool to build the program.
+
+CRITICAL: Only use exercise names that EXACTLY match the provided library. Do not invent exercises or modify names.
+
+EXERCISE LIBRARY:
+${exerciseLib}${customLib}
+
+PROGRAM DESIGN PRINCIPLES:
+- Consider the user's experience level, goals, injuries, and available equipment
+- Place compound lifts first in each day
+- Balance push/pull volume
+- Include appropriate warm-up progression in set counts
+- Use appropriate rep ranges for the exercise type (compounds: 3-8, accessories: 8-15)
+- Add helpful notes for exercises that need form cues or injury modifications
+- Respect any injuries or limitations mentioned`;
+
+  try {
+    const result = await aiProvider.chatWithTools(system, [
+      { role: "user", content: `${context}\n\nPROGRAM REQUEST: ${prompt}` },
+    ], [PROGRAM_TOOL], { maxTokens: 4000 });
+
+    const programCall = result.toolCalls?.find(tc => tc.name === "create_program");
+    if (programCall) {
+      // Validate exercise names against library
+      const allNames = new Set([...exerciseNames, ...customExs.map(e => e.name)]);
+      const program = programCall.input;
+      const unknowns = [];
+      program.days?.forEach(day => {
+        day.exercises?.forEach(ex => {
+          if (!allNames.has(ex.name)) unknowns.push(ex.name);
+        });
+        // Add IDs for frontend compatibility
+        day.id = genId();
+      });
+
+      res.json({
+        program,
+        unknownExercises: unknowns,
+        commentary: result.text || null,
+      });
+    } else {
+      // No tool call â€” return text response
+      res.json({ program: null, commentary: result.text || "Could not generate program. Try being more specific." });
+    }
+  } catch (e) {
+    console.error("Program builder error:", e.message);
+    res.status(500).json({ error: e.message });
+  }
+});
+
+// ===================== AI SESSION ANALYSIS =====================
+
+app.post("/api/coach/analyze", async (req, res) => {
+  if (!aiProvider) return res.status(503).json({ error: "AI coach unavailable â€” no provider configured" });
+  const { workout, context } = req.body;
+
+  const system = `You are a concise strength training coach providing a post-workout session analysis. Analyze the just-completed workout and give brief, specific feedback.
+
+FORMAT YOUR RESPONSE IN THESE SECTIONS (skip any that aren't relevant):
+**Session Summary** â€” One line overview (duration, volume, energy)
+**PRs & Wins** â€” Any personal records or notable improvements
+**Flags** â€” Any regressions, concerning patterns, or things to watch
+**Next Session** â€” One specific, actionable recommendation for next time
+
+Keep it tight â€” max 150 words total. Be encouraging but honest. Use the user's actual numbers.`;
+
+  try {
+    const result = await aiProvider.chat(system, [
+      { role: "user", content: `${context}\n\nJUST COMPLETED:\n${JSON.stringify(workout, null, 2)}` },
+    ], { maxTokens: 800 });
+    res.json({ analysis: result.text });
+  } catch (e) {
+    console.error("Analysis error:", e.message);
+    res.status(500).json({ error: e.message });
+  }
+});
+
 // ===================== EXPORT =====================
 
 app.get("/api/export", (req, res) => {
@@ -352,7 +546,13 @@ app.get("/api/export", (req, res) => {
 
 // Health
 app.get("/api/health", (req, res) => {
-  res.json({ status: "ok", users: db.prepare("SELECT COUNT(*) as c FROM users").get().c, ai: !!anthropic });
+  res.json({
+    status: "ok",
+    users: db.prepare("SELECT COUNT(*) as c FROM users").get().c,
+    ai: !!aiProvider,
+    aiProvider: aiProvider?.providerName || null,
+    aiModel: aiProvider?.modelName || null,
+  });
 });
 
 // SPA fallback
@@ -361,14 +561,15 @@ if (process.env.NODE_ENV === "production") {
 }
 
 app.listen(PORT, "0.0.0.0", () => {
+  const aiStatus = aiProvider ? `âœ… ${aiProvider.providerName} (${aiProvider.modelName})` : "âŒ Not configured";
   console.log(`
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                                        â”‚
 â”‚   â—† FORGE                              â”‚
-â”‚   Gym Tracker v2.0                     â”‚
+â”‚   Gym Tracker v2.1                     â”‚
 â”‚                                        â”‚
 â”‚   http://0.0.0.0:${String(PORT).padEnd(24)}â”‚
-â”‚   AI Coach: ${(anthropic ? "âœ… Enabled" : "âŒ No API key").padEnd(26)}â”‚
+â”‚   AI: ${aiStatus.padEnd(33)}â”‚
 â”‚   Users: ${String(db.prepare("SELECT COUNT(*) as c FROM users").get().c).padEnd(29)}â”‚
 â”‚                                        â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`);
diff --git a/src/App.jsx b/src/App.jsx
index 726e996..80869db 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -1151,13 +1151,78 @@ function MarkdownText({ text }) {
   return <div className="md-response" dangerouslySetInnerHTML={{ __html: html }} />;
 }
 
+// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SESSION RECAP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+function SessionRecap({ summary, onDone }) {
+  if (!summary) return null;
+  const { workout, analysis, loading } = summary;
+  const totalSets = workout.exercises?.reduce((t, e) => t + (e.sets?.length || 0), 0) || 0;
+  const totalVolume = workout.exercises?.reduce((t, e) => t + (e.sets?.reduce((st, s) => st + ((s.weight || 0) * (s.reps || 0)), 0) || 0), 0) || 0;
+  const feelInfo = FEEL.find(f => f.v === workout.feel) || FEEL[2];
+
+  return (
+    <div className="fade-in">
+      <div style={S.card}>
+        <div style={{ textAlign: "center", marginBottom: 12 }}>
+          <div style={{ fontSize: 28, marginBottom: 4 }}>âœ“</div>
+          <div style={{ fontSize: 16, fontWeight: 800, color: "#22c55e" }}>Session Complete</div>
+          <div style={{ fontSize: 11, color: "#737373", marginTop: 2 }}>{workout.day_label || "Workout"} Â· {fmtDate(workout.date)}</div>
+        </div>
+        <div style={{ display: "flex", gap: 12, justifyContent: "center", marginBottom: 12 }}>
+          <div style={{ textAlign: "center" }}>
+            <div style={{ fontSize: 18, fontWeight: 800, color: "#fafafa" }}>{workout.duration || "?"}</div>
+            <div style={{ fontSize: 9, color: "#525252", textTransform: "uppercase" }}>min</div>
+          </div>
+          <div style={{ textAlign: "center" }}>
+            <div style={{ fontSize: 18, fontWeight: 800, color: "#fafafa" }}>{workout.exercises?.length || 0}</div>
+            <div style={{ fontSize: 9, color: "#525252", textTransform: "uppercase" }}>exercises</div>
+          </div>
+          <div style={{ textAlign: "center" }}>
+            <div style={{ fontSize: 18, fontWeight: 800, color: "#fafafa" }}>{totalSets}</div>
+            <div style={{ fontSize: 9, color: "#525252", textTransform: "uppercase" }}>sets</div>
+          </div>
+          <div style={{ textAlign: "center" }}>
+            <div style={{ fontSize: 18, fontWeight: 800, color: "#fafafa" }}>{totalVolume > 0 ? `${(totalVolume / 1000).toFixed(1)}k` : "â€”"}</div>
+            <div style={{ fontSize: 9, color: "#525252", textTransform: "uppercase" }}>lbs vol</div>
+          </div>
+          <div style={{ textAlign: "center" }}>
+            <div style={{ fontSize: 18, fontWeight: 800, color: feelInfo.c }}>{feelInfo.l}</div>
+            <div style={{ fontSize: 9, color: "#525252", textTransform: "uppercase" }}>feel</div>
+          </div>
+        </div>
+      </div>
+
+      {(loading || analysis) && (
+        <div style={S.card}>
+          <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
+            <span style={{ fontSize: 14 }}>âš¡</span>
+            <div style={S.label}>AI Analysis</div>
+          </div>
+          {loading ? (
+            <div style={{ padding: 8, textAlign: "center", color: "#f97316", fontSize: 12 }}>Analyzing session...</div>
+          ) : (
+            <MarkdownText text={analysis} />
+          )}
+        </div>
+      )}
+
+      <div style={{ padding: "0 16px" }}>
+        <button onClick={onDone} style={{ ...S.btn("primary"), width: "100%" }}>Done</button>
+      </div>
+    </div>
+  );
+}
+
 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COACH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
 function CoachPage() {
-  const { workouts, profile, programs, user } = useForge();
+  const { workouts, profile, programs, user, saveProgram } = useForge();
   const [prompt, setPrompt] = useState("");
   const [response, setResponse] = useState("");
   const [loading, setLoading] = useState(false);
+  const [mode, setMode] = useState("chat"); // "chat" | "program"
+  const [programPreview, setProgramPreview] = useState(null); // { program, commentary, unknownExercises }
+  const [programSaving, setProgramSaving] = useState(false);
 
   const prs = {};
   workouts.forEach(w => w.exercises?.forEach(ex => ex.sets?.forEach(s => {
@@ -1166,8 +1231,7 @@ function CoachPage() {
     if (!prs[ex.name] || (e && e > (prs[ex.name].e1rm || 0))) prs[ex.name] = { weight: s.weight, reps: s.reps, e1rm: e, date: w.date };
   })));
 
-  async function ask(q) {
-    setLoading(true); setResponse("");
+  function buildContext() {
     const recent = workouts.slice(-10);
     const programCtx = programs.filter(p => p.user_id === user.id).map(p =>
     `${p.name}${p.description ? ` (${p.description})` : ""}:\n${p.days?.map((d, i) =>
@@ -1192,19 +1256,54 @@ function CoachPage() {
     const targetPrLines = profile.targetPrs && Object.keys(profile.targetPrs).length > 0
       ? `TARGET PRs:\n${Object.entries(profile.targetPrs).filter(([, v]) => v).map(([k, v]) => `${k}: ${v} lbs`).join("\n")}` : "";
     const injuryLines = profile.injuriesNotes ? `INJURIES/LIMITATIONS: ${profile.injuriesNotes}` : "";
-    const context = `USER: ${profileLines}
+    return `USER: ${profileLines}
     ${injuryLines}
     ${targetPrLines}
     PROGRAMS:\n${programCtx || "None"}
     PRs:\n${Object.entries(prs).slice(0, 15).map(([k, v]) => `${k}: ${v.weight}x${v.reps} (e1RM: ${v.e1rm || "?"})`).join("\n")}
     RECENT (${recent.length}):\n${recent.map(w => `${w.date} ${w.day_label || ""} (Feel:${w.feel}/5)\n${w.exercises?.map(e => `  ${e.name}: ${e.sets?.map(s => `${s.weight}x${s.reps}`).join(", ")}`).join("\n") || ""}`).join("\n\n")}`;
+  }
+
+  async function ask(q) {
+    setLoading(true); setResponse("");
     try {
-      const data = await api.post("/coach", { prompt: q, context });
+      const data = await api.post("/coach", { prompt: q, context: buildContext() });
       setResponse(data.response || data.error || "No response.");
     } catch (e) { setResponse("Error: " + e.message); }
     setLoading(false);
   }
 
+  async function buildProgram(q) {
+    setLoading(true); setProgramPreview(null); setResponse("");
+    try {
+      const data = await api.post("/coach/program", { prompt: q, context: buildContext() });
+      if (data.program) {
+        setProgramPreview(data);
+      } else {
+        setResponse(data.commentary || "Could not generate program. Try being more specific about what you want.");
+      }
+    } catch (e) { setResponse("Error: " + e.message); }
+    setLoading(false);
+  }
+
+  async function saveProgramFromPreview() {
+    if (!programPreview?.program) return;
+    setProgramSaving(true);
+    try {
+      await saveProgram({
+        id: null,
+        name: programPreview.program.name,
+        description: programPreview.program.description || "",
+        days: programPreview.program.days,
+        shared: false,
+        user_id: user.id,
+      });
+      setProgramPreview(null);
+      setResponse("âœ… Program saved! Check the Programs tab.");
+    } catch (e) { setResponse("Error saving: " + e.message); }
+    setProgramSaving(false);
+  }
+
   const quick = [
     { l: "Next workout", p: "Give me specific target weights and reps for my next workout based on progressive overload." },
     { l: "Plateau advice", p: "Analyze my data for any lifts that have plateaued and give me a plan to break through." },
@@ -1222,17 +1321,87 @@ function CoachPage() {
             <div style={{ fontSize: 10, color: "#525252" }}>Analyzes your last {Math.min(workouts.length, 10)} workouts</div>
           </div>
         </div>
-        <div style={S.label}>Quick Actions</div>
-        <div style={{ display: "flex", flexWrap: "wrap", gap: 5, marginBottom: 12 }}>
-          {quick.map((q, i) => <button key={i} onClick={() => { setPrompt(q.p); ask(q.p); }} style={S.sm()}>{q.l}</button>)}
+
+        {/* Mode toggle */}
+        <div style={{ display: "flex", gap: 4, marginBottom: 12, background: "#171717", borderRadius: 6, padding: 3 }}>
+          <button onClick={() => { setMode("chat"); setProgramPreview(null); }} style={{ ...S.sm(mode === "chat" ? "primary" : "ghost"), flex: 1, textAlign: "center" }}>ğŸ’¬ Chat</button>
+          <button onClick={() => { setMode("program"); setResponse(""); }} style={{ ...S.sm(mode === "program" ? "primary" : "ghost"), flex: 1, textAlign: "center" }}>ğŸ“‹ Build Program</button>
         </div>
-        <div style={S.label}>Ask Anything</div>
-        <textarea value={prompt} onChange={e => setPrompt(e.target.value)} style={{ ...S.input, minHeight: 50, resize: "vertical", marginBottom: 8 }} placeholder="Programming, nutrition, substitutions..." />
-        <button onClick={() => ask(prompt)} disabled={loading || !prompt.trim()} style={{ ...S.btn("primary"), width: "100%", opacity: (loading || !prompt.trim()) ? 0.5 : 1 }}>
-          {loading ? "Analyzing..." : "Ask Coach"}
-        </button>
+
+        {mode === "chat" && (
+          <>
+            <div style={S.label}>Quick Actions</div>
+            <div style={{ display: "flex", flexWrap: "wrap", gap: 5, marginBottom: 12 }}>
+              {quick.map((q, i) => <button key={i} onClick={() => { setPrompt(q.p); ask(q.p); }} style={S.sm()}>{q.l}</button>)}
+            </div>
+            <div style={S.label}>Ask Anything</div>
+            <textarea value={prompt} onChange={e => setPrompt(e.target.value)} style={{ ...S.input, minHeight: 50, resize: "vertical", marginBottom: 8 }} placeholder="Programming, nutrition, substitutions..." />
+            <button onClick={() => ask(prompt)} disabled={loading || !prompt.trim()} style={{ ...S.btn("primary"), width: "100%", opacity: (loading || !prompt.trim()) ? 0.5 : 1 }}>
+              {loading ? "Analyzing..." : "Ask Coach"}
+            </button>
+          </>
+        )}
+
+        {mode === "program" && (
+          <>
+            <div style={S.label}>Describe Your Program</div>
+            <textarea value={prompt} onChange={e => setPrompt(e.target.value)} style={{ ...S.input, minHeight: 70, resize: "vertical", marginBottom: 8 }}
+              placeholder="e.g. Build me a 4-day upper/lower split focused on hypertrophy. I train Mon/Tue/Thu/Fri. Avoid deep squats due to hip bursitis." />
+            <button onClick={() => buildProgram(prompt)} disabled={loading || !prompt.trim()} style={{ ...S.btn("primary"), width: "100%", opacity: (loading || !prompt.trim()) ? 0.5 : 1 }}>
+              {loading ? "Building program..." : "Generate Program"}
+            </button>
+          </>
+        )}
       </div>
-      {(response || loading) && (
+
+      {/* Program Preview */}
+      {programPreview?.program && (
+        <div style={S.card}>
+          <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
+            <span style={{ fontSize: 14 }}>ğŸ“‹</span>
+            <div style={S.label}>Generated Program</div>
+          </div>
+          <div style={{ fontSize: 15, fontWeight: 800, color: "#fafafa", marginBottom: 2 }}>{programPreview.program.name}</div>
+          {programPreview.program.description && <div style={{ fontSize: 11, color: "#737373", marginBottom: 8 }}>{programPreview.program.description}</div>}
+
+          {programPreview.unknownExercises?.length > 0 && (
+            <div style={{ background: "#451a03", border: "1px solid #92400e", borderRadius: 6, padding: 8, marginBottom: 8, fontSize: 11, color: "#fbbf24" }}>
+              âš  Unknown exercises (not in library): {programPreview.unknownExercises.join(", ")}
+            </div>
+          )}
+
+          {programPreview.program.days?.map((day, di) => (
+            <div key={di} style={{ background: "#171717", borderRadius: 6, padding: 10, marginBottom: 6 }}>
+              <div style={{ fontSize: 12, fontWeight: 700, color: "#fafafa", marginBottom: 2 }}>
+                Day {di + 1} â€” {day.label}
+                {day.subtitle && <span style={{ fontWeight: 400, color: "#737373" }}> ({day.subtitle})</span>}
+              </div>
+              {day.exercises?.map((ex, ei) => (
+                <div key={ei} style={{ fontSize: 11, color: "#a3a3a3", paddingLeft: 8, marginTop: 3, display: "flex", justifyContent: "space-between" }}>
+                  <span>{ex.name}</span>
+                  <span style={{ color: "#525252" }}>{ex.defaultSets}Ã—{ex.targetReps}{ex.notes ? ` Â· ${ex.notes}` : ""}</span>
+                </div>
+              ))}
+            </div>
+          ))}
+
+          {programPreview.commentary && (
+            <div style={{ marginTop: 8, marginBottom: 8 }}>
+              <MarkdownText text={programPreview.commentary} />
+            </div>
+          )}
+
+          <div style={{ display: "flex", gap: 8, marginTop: 10 }}>
+            <button onClick={() => setProgramPreview(null)} style={{ ...S.btn("ghost"), flex: 1 }}>Dismiss</button>
+            <button onClick={saveProgramFromPreview} disabled={programSaving} style={{ ...S.btn("primary"), flex: 2, opacity: programSaving ? 0.5 : 1 }}>
+              {programSaving ? "Saving..." : "Save to Programs"}
+            </button>
+          </div>
+        </div>
+      )}
+
+      {/* Text Response */}
+      {(response || (loading && !programPreview)) && (
         <div style={S.card}>
           <div style={S.label}>Response</div>
           {loading ? <div style={{ padding: 16, textAlign: "center", color: "#f97316", fontSize: 12 }}>Analyzing training data...</div>
@@ -1250,18 +1419,55 @@ function SettingsModal({ onClose, onLogout }) {
   const [name, setName] = useState(user.name);
   const [newPin, setNewPin] = useState("");
   const [color, setColor] = useState(user.color);
+  const [showAI, setShowAI] = useState(false);
+  const [aiForm, setAiForm] = useState({ provider: "", model: "", apiKey: "", baseUrl: "", supportsTools: true });
+  const [aiStatus, setAiStatus] = useState("");
+  const [aiLoaded, setAiLoaded] = useState(false);
+
+  useEffect(() => {
+    if (showAI && !aiLoaded) {
+      api.get("/ai/config").then(cfg => {
+        setAiForm({
+          provider: cfg.provider || "anthropic",
+          model: cfg.model || "",
+          apiKey: "", // Don't prefill key
+          baseUrl: cfg.baseUrl || "",
+          supportsTools: cfg.supportsTools !== false,
+        });
+        setAiStatus(cfg.enabled ? `Active: ${cfg.providerName}` : "Not configured");
+        setAiLoaded(true);
+      }).catch(() => setAiLoaded(true));
+    }
+  }, [showAI]);
 
   async function save() {
     const payload = { name, color };
     if (newPin) payload.pin = newPin;
     await api.put(`/users/${user.id}`, payload);
     onClose();
-    window.location.reload(); // Simplest way to refresh user data
+    window.location.reload();
   }
 
+  async function saveAI() {
+    setAiStatus("Saving...");
+    try {
+      const body = { provider: aiForm.provider, model: aiForm.model, baseUrl: aiForm.baseUrl, supportsTools: aiForm.supportsTools };
+      if (aiForm.apiKey) body.apiKey = aiForm.apiKey;
+      const res = await api.put("/ai/config", body);
+      setAiStatus(res.enabled ? `Active: ${res.providerName}` : "Configuration saved (no API key)");
+    } catch (e) { setAiStatus("Error: " + e.message); }
+  }
+
+  const PROVIDERS = [
+    { id: "anthropic", label: "Anthropic (Claude)" },
+    { id: "openai", label: "OpenAI" },
+    { id: "gemini", label: "Google Gemini" },
+    { id: "openai-compatible", label: "Custom (Ollama, LM Studio, etc.)" },
+  ];
+
   return (
     <div style={{ position: "fixed", inset: 0, background: "rgba(0,0,0,0.85)", zIndex: 300, display: "flex", alignItems: "center", justifyContent: "center", padding: 16 }}>
-      <div style={{ ...S.card, margin: 0, maxWidth: 340, width: "100%" }}>
+      <div style={{ ...S.card, margin: 0, maxWidth: 360, width: "100%", maxHeight: "85vh", overflowY: "auto" }}>
         <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 16 }}>
           <div style={S.label}>Settings</div>
           <button onClick={onClose} style={S.sm()}>âœ•</button>
@@ -1280,6 +1486,55 @@ function SettingsModal({ onClose, onLogout }) {
             {USER_COLORS.map(c => <div key={c} onClick={() => setColor(c)} style={{ width: 24, height: 24, borderRadius: "50%", background: c, cursor: "pointer", border: color === c ? "3px solid #fff" : "3px solid transparent" }} />)}
           </div>
         </div>
+
+        {/* AI Provider Config */}
+        <div style={{ borderTop: "1px solid #262626", paddingTop: 12, marginBottom: 12 }}>
+          <div onClick={() => setShowAI(!showAI)} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", cursor: "pointer" }}>
+            <div style={{ fontSize: 10, color: "#525252", textTransform: "uppercase" }}>AI Coach Provider</div>
+            <span style={{ color: "#525252", fontSize: 12, transform: showAI ? "rotate(180deg)" : "rotate(0deg)", transition: "transform 0.2s" }}>â–¼</span>
+          </div>
+          {aiStatus && <div style={{ fontSize: 10, color: "#737373", marginTop: 2 }}>{aiStatus}</div>}
+        </div>
+
+        {showAI && (
+          <div style={{ marginBottom: 16 }}>
+            <div style={{ marginBottom: 8 }}>
+              <div style={{ fontSize: 10, color: "#525252", marginBottom: 3, textTransform: "uppercase" }}>Provider</div>
+              <select value={aiForm.provider} onChange={e => setAiForm(f => ({ ...f, provider: e.target.value, model: "" }))} style={{ ...S.input, fontSize: 12 }}>
+                {PROVIDERS.map(p => <option key={p.id} value={p.id}>{p.label}</option>)}
+              </select>
+            </div>
+            <div style={{ marginBottom: 8 }}>
+              <div style={{ fontSize: 10, color: "#525252", marginBottom: 3, textTransform: "uppercase" }}>Model</div>
+              <input value={aiForm.model} onChange={e => setAiForm(f => ({ ...f, model: e.target.value }))} style={{ ...S.input, fontSize: 12 }} placeholder="e.g. claude-sonnet-4-20250514, gpt-4o, gemini-2.0-flash" />
+            </div>
+            {aiForm.provider !== "openai-compatible" && (
+              <div style={{ marginBottom: 8 }}>
+                <div style={{ fontSize: 10, color: "#525252", marginBottom: 3, textTransform: "uppercase" }}>API Key (leave blank to keep current)</div>
+                <input type="password" value={aiForm.apiKey} onChange={e => setAiForm(f => ({ ...f, apiKey: e.target.value }))} style={{ ...S.input, fontSize: 12 }} placeholder="sk-..." />
+              </div>
+            )}
+            {aiForm.provider === "openai-compatible" && (
+              <>
+                <div style={{ marginBottom: 8 }}>
+                  <div style={{ fontSize: 10, color: "#525252", marginBottom: 3, textTransform: "uppercase" }}>Base URL</div>
+                  <input value={aiForm.baseUrl} onChange={e => setAiForm(f => ({ ...f, baseUrl: e.target.value }))} style={{ ...S.input, fontSize: 12 }} placeholder="http://localhost:11434/v1" />
+                </div>
+                <div style={{ marginBottom: 8 }}>
+                  <div style={{ fontSize: 10, color: "#525252", marginBottom: 3, textTransform: "uppercase" }}>API Key (optional for local)</div>
+                  <input type="password" value={aiForm.apiKey} onChange={e => setAiForm(f => ({ ...f, apiKey: e.target.value }))} style={{ ...S.input, fontSize: 12 }} placeholder="Leave blank for Ollama" />
+                </div>
+                <label style={{ display: "flex", alignItems: "center", gap: 8, fontSize: 11, color: "#737373", cursor: "pointer", marginBottom: 8 }}>
+                  <input type="checkbox" checked={aiForm.supportsTools} onChange={e => setAiForm(f => ({ ...f, supportsTools: e.target.checked }))} />
+                  Supports tool/function calling
+                </label>
+              </>
+            )}
+            <button onClick={saveAI} style={{ ...S.btn("ghost"), width: "100%", fontSize: 11 }}>Save AI Config</button>
+            <div style={{ fontSize: 9, color: "#525252", marginTop: 4, textAlign: "center" }}>Key stored in local database. Server-level .env takes priority if set.</div>
+          </div>
+        )}
+
         <div style={{ display: "flex", gap: 8 }}>
           <button onClick={onLogout} style={{ ...S.btn("ghost"), flex: 1 }}>Log Out</button>
           <button onClick={save} style={{ ...S.btn("primary"), flex: 1 }}>Save</button>
@@ -1302,6 +1557,8 @@ export default function App() {
   const [showSettings, setShowSettings] = useState(false);
   const [editingProgram, setEditingProgram] = useState(null);
   const [loaded, setLoaded] = useState(false);
+  const [aiConfig, setAiConfig] = useState({ enabled: false, provider: "", model: "" });
+  const [sessionSummary, setSessionSummary] = useState(null); // { workout, analysis, loading }
 
   // Load user data
   useEffect(() => {
@@ -1312,11 +1569,13 @@ export default function App() {
       api.get(`/profile?user_id=${user.id}`),
       api.get(`/programs?user_id=${user.id}`),
       api.get("/exercises"),
-    ]).then(([w, p, pr, ex]) => {
+      api.get("/ai/config"),
+    ]).then(([w, p, pr, ex, ai]) => {
       setWorkouts(w);
       setProfile(p);
       setPrograms(pr);
       setCustomExercises(ex);
+      setAiConfig(ai);
       setLoaded(true);
     }).catch(e => { console.error(e); setLoaded(true); });
   }, [user]);
@@ -1386,8 +1645,40 @@ export default function App() {
       exercises: currentWorkout.exercises,
     };
     await saveWorkout(payload);
+
+    // Show session recap and trigger AI analysis
+    const summaryData = { workout: payload, analysis: null, loading: aiConfig.enabled };
+    setSessionSummary(summaryData);
     setCurrent(null);
-    setTab("history");
+    setTab("summary");
+
+    // Fire AI analysis in background
+    if (aiConfig.enabled) {
+      try {
+        const recent = workouts.slice(-5);
+        const age = profile.dateOfBirth ? Math.floor((Date.now() - new Date(profile.dateOfBirth + "T12:00:00").getTime()) / 31557600000) : null;
+        const profileLines = [
+          profile.sex ? `Sex: ${profile.sex}` : null,
+          age ? `Age: ${age}` : null,
+          profile.weight ? `Weight: ${profile.weight} lbs` : null,
+          profile.goal ? `Goal: ${profile.goal}` : null,
+          profile.experienceLevel ? `Experience: ${profile.experienceLevel}` : null,
+          profile.injuriesNotes ? `Injuries: ${profile.injuriesNotes}` : null,
+        ].filter(Boolean).join(", ");
+
+        // Find previous sessions for same day label
+        const sameDaySessions = workouts.filter(w => w.day_label === payload.day_label).slice(-3);
+        const prevCtx = sameDaySessions.length > 0
+          ? `PREVIOUS ${payload.day_label || "SESSION"} HISTORY:\n${sameDaySessions.map(w => `${w.date} (Feel:${w.feel}/5, ${w.duration}min)\n${w.exercises?.map(e => `  ${e.name}: ${e.sets?.map(s => `${s.weight}x${s.reps}`).join(", ")}`).join("\n") || ""}`).join("\n\n")}`
+          : "";
+
+        const context = `USER: ${profileLines}\n${prevCtx}`;
+        const data = await api.post("/coach/analyze", { workout: payload, context });
+        setSessionSummary(prev => prev ? { ...prev, analysis: data.analysis, loading: false } : null);
+      } catch (e) {
+        setSessionSummary(prev => prev ? { ...prev, analysis: "Analysis unavailable.", loading: false } : null);
+      }
+    }
   }
 
   // Auth gate
@@ -1400,7 +1691,7 @@ export default function App() {
 
   const activeTab = currentWorkout && tab === "log" ? "active" : tab;
 
-  const ctx = { user, workouts, profile, programs, customExercises, saveWorkout, deleteWorkout, updateProfile, saveProgram, deleteProgram, addCustomExercise, editingProgram, setEditingProgram };
+  const ctx = { user, workouts, profile, programs, customExercises, saveWorkout, deleteWorkout, updateProfile, saveProgram, deleteProgram, addCustomExercise, editingProgram, setEditingProgram, aiConfig };
 
   return (
     <Ctx.Provider value={ctx}>
@@ -1418,6 +1709,7 @@ export default function App() {
             onFinish={finishWorkout} onDiscard={() => { if (confirm("Discard this workout? All logged sets will be lost.")) { setCurrent(null); setTab("log"); } }} />
         )}
         {activeTab === "active" && !currentWorkout && <LogPage onStartWorkout={startWorkout} />}
+        {activeTab === "summary" && <SessionRecap summary={sessionSummary} onDone={() => { setSessionSummary(null); setTab("history"); }} />}
         {activeTab === "history" && <HistoryPage />}
         {activeTab === "stats" && <StatsPage />}
         {activeTab === "programs" && <ProgramsPage />}
